# -*- coding: utf-8 -*-
"""Copy of Smallworld.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12B3BgTnWOg6ANjqXbfiGvrm5dMTdast-

### Mudei a implementação mas acho que ta funcionando agora
"""

#pip install networkx

import random 
import math 

class Aresta:
  def __init__(self, distancia, origem, destino):
    self.distancia = distancia
    self.origem = origem
    self.destino = destino

def f(a):
  return a.distancia

def seleciona(lista, k, MatrizArestas):
  #ordena as distancias em ordem crescente 
  lista.sort(key=f) 
  lista = lista[:k]
  for i in range (0, k):
    #estabelecemos conexoes bi-direcionais
    MatrizArestas[lista[i].origem][lista[i].destino] = lista[i].distancia
    MatrizArestas[lista[i].destino][lista[i].origem] = lista[i].distancia

  return MatrizArestas


def gera_vertices(n):
  lista = []
  for i in range (0, n):
    numx = random.random() * n
    numy = random.random() * n
    parord = [numx, numy]
    lista.append(parord)
  return lista

def gera_arestas(lista, k):
  tamanho = len(lista) 
  MatrizArestas = [[0]*tamanho for i in range(tamanho)]

  for x in range(tamanho):
     for y in range(tamanho):
        MatrizArestas[x][y] = -1 #definimos distancias negativas como nao conexoes

  for origem in range(0, tamanho):
    distElem = [] #criamos uma lista de distancias de um elemento para todos os outros
    for destino in range(0, tamanho):
      if(origem != destino): #para que ele nao possa se conectar com ele mesmo
        distElem.append(Aresta(math.sqrt(pow(lista[origem][0] - lista[destino][0], 2) + pow(lista[origem][1] - lista[destino][1], 2)), origem, destino))

    #seleciona as k menores distancias e atualiza a matriz
    MatrizArestas = seleciona(distElem, k, MatrizArestas)

  return MatrizArestas

def gera_rede_knn(n, k):
  listavertices = gera_vertices(n)
  grafo = gera_arestas(listavertices, k)

  return listavertices, grafo

def reconecta_aresta(listavertices, grafo, p): 
  tamanho = len(listavertices) 
  for vert in range(tamanho):
    for aresta in range(vert + 1): # como a matrix eh simetrica nao precisamos percorrer ela por completo, apenas ate a diagonal principal
      if(grafo[vert][aresta] != -1 and p > random.random()): #cria nova conexao
        grafo[vert][aresta] = -1 #apaga a conexao
        grafo[aresta][vert] = -1
        
        n = 1
        while(n):
          novaConec = int(random.random() * tamanho)
          if(novaConec != vert): #nao pode se conectar consigo mesmo
            n = 0

        novaDist = math.sqrt(pow(listavertices[vert][0] - listavertices[novaConec][0], 2) + pow(listavertices[vert][1] - listavertices[novaConec][1], 2))

        grafo[vert][novaConec] = novaDist
        grafo[novaConec][vert] = novaDist


  return grafo

def printa(Grafo):
  for i in range(len(Grafo)):
    print('Vertice:', i)
    for j in range(len(Grafo[i])):
      if(Grafo[i][j] != -1):
        print('Conexões:', j, 'Distancia:', round(Grafo[i][j], 3))

ListVert, Grafo = gera_rede_knn(100, 3)
#printa(Grafo)
#print('-------------------------------------------------------------------')
reconecta_aresta(ListVert, Grafo, 0.1)
#printa(Grafo)


import networkx as nx
import matplotlib.pyplot as plt

class VisualGrafo:
  def __init__(self):
    self.aresta = []
  
  def adiciona(self, conexao):
    self.aresta.append(conexao)
  
  def visualizacao(self):
    G = nx.Graph()
    G.add_edges_from(self.aresta)
    nx.draw_networkx(G)
    plt.show()

G = VisualGrafo()
for i in range(len(Grafo)):
    for j in range(i + 1):
      if(Grafo[i][j] != -1):
        G.adiciona([i, j]) 
         
G.visualizacao()

"""#Busca em Largura

"""

#busca largura 

import time

caseLargura = 1
caseProf = 2
caseBestFirst = 3
caseA = 4

G = VisualGrafo()
for i in range(len(Grafo)):
    for j in range(i + 1):
      if(Grafo[i][j] != -1):
        G.adiciona([i, j]) 

G1 = nx.Graph()
G1.add_edges_from(G.aresta)
print(G1.nodes)
pos = nx.spring_layout(G=G1, seed=42)

#time.sleep(2)

def atualiza_grafo(grafo, a, color_map, num, case):
  lista_nodes = list(G1.nodes)
  for i in range(len(lista_nodes)):
    if lista_nodes[i] == a:
      color_map[i] = 'red'
  nx.draw_networkx(G1, pos=pos, node_color=color_map)  

  if case == caseLargura:
    filename = 'Largura/largura' + str(num) + '.png'

  if case == caseProf:
    filename = 'Profundidade/profundidade' + str(num) + '.png'

  if case == caseBestFirst:
    filename = 'BestFirst/bf' + str(num) + '.png'

  if case == caseA:
    filename = 'AlgoritmoA/A' + str(num) + '.png'
  
  plt.savefig(filename)
  #plt.show()
  #time.sleep(2)
  plt.close()

def busca_largura(o, d, grafo):
  fila = [o] # Fila dos vértices que serão analisados
  visitado = [False] * len(grafo)
  visitado[o] = True
  dist = 0
  cam = []

  color_map = ['blue'] * len(G1.nodes)

  number_pictures = 0
  while fila != []:
    a = fila.pop(0)
    
    cam.append(a)
    atualiza_grafo(grafo, a, color_map, number_pictures, caseLargura)

    if(a == d):
      return cam, dist

    for i in range (len(grafo[a])): # for para adicionar os filhos do grafo atual na fila
      if visitado[i] == False and grafo[a][i] > 0: # caso nao esteja conectado, grafo[a][i] == -1, portanto precisa checar se é maior que 0
        fila.append(i)
        visitado[i] = True
        dist += grafo[a][i]
        if i == d: # Se alcancar o destino, nao soma as  distancias dos filhos subsequentes
          break

    number_pictures = number_pictures + 1

  return [], -1

o = 0
d = 4
cam, dist = busca_largura(o, d, Grafo)
print(cam)
print(round(dist, 2))

"""#Busca em Profundidade"""

#busca profundidade

def busca_prof_rec(o, d, grafo, visitado, dist, parada, color_map, number_pictures):
  number_pictures = number_pictures + 1
  atualiza_grafo(grafo, o, color_map, number_pictures, caseProf)
  visitado.append(o)
  for i in range (len(grafo[o])):
    if i not in visitado and grafo[o][i] > 0:
      if parada == True:
        return visitado, dist, parada, number_pictures
      dist += grafo[o][i]
      if i == d:
        visitado.append(i)
        parada = True
        return visitado, dist, parada, number_pictures
      visitado, dist, parada, number_pictures = busca_prof_rec(i, d, grafo, visitado, dist, parada, color_map, number_pictures)

  return visitado, dist, parada, number_pictures

def busca_profundidade(o, d, grafo):
  visitado = []
  parada = False
  dist = 0
  color_map = ['blue'] * len(G1.nodes)

  number_pictures = -1

  visitado, dist, parada, number_pictures = busca_prof_rec(o, d, grafo, visitado, dist, parada, color_map, number_pictures)
  if parada == True:
    atualiza_grafo(grafo, d, color_map, number_pictures, caseProf)
  else:
    visitado = []
    dist = -1
  return visitado, dist

o = 0
d = 4

cam, dist = busca_profundidade(o, d, Grafo)
print(cam)
print(round(dist, 2))



"""#Busca Best-First"""

import time
from queue import PriorityQueue

def g(a):
  return a.get()[1] 

def busca_largura_heuristica(o, d, grafo):
  fila = [o] # Fila dos vértices que serão analisados
  visitado = [False] * len(grafo)
  visitado[o] = True

  pq = PriorityQueue()
  pq.put((0, o))
  
  dist = 0
  cam = []

  color_map = ['blue'] * len(G1.nodes)

  number_pictures = 0
  while pq.empty() == False:
    #print('Fila de prioridade:', pq.queue)
    a = pq.get()[1]
    #a = fila.pop(0)
    
    cam.append(a)
    atualiza_grafo(grafo, a, color_map, number_pictures, caseBestFirst)

    if(a == d):
      return cam, dist

    for i in range (len(grafo[a])): # for para adicionar os filhos do grafo atual na fila
      if visitado[i] == False and grafo[a][i] > 0: # caso nao esteja conectado, grafo[a][i] == -1, portanto precisa checar se é maior que 0
        pq.put((grafo[a][i], i))
        #pq.sort(key = g)
        visitado[i] = True
        dist += grafo[a][i]
        if i == d: # Se alcancar o destino, nao soma as  distancias dos filhos subsequentes
          break

    number_pictures = number_pictures + 1

  return [], -1

o = 0
d = 4
#printa(Grafo)
cam, dist = busca_largura_heuristica(o, d, Grafo)
#print(cam)
#print(round(dist, 2))



#Algoritmo A*


#busca A* 
#busca A* 
'''
for i in range(len(Grafo)):
  print('Vertice: ', i)
  for j in range (len(Grafo[i])):
    print('Conexao: ', j, 'Distancia: ', Grafo[i][j])
'''
G = VisualGrafo()
for i in range(len(Grafo)):
    for j in range(i + 1):
      if(Grafo[i][j] != -1):
        G.adiciona([i, j]) 

G1 = nx.Graph()
G1.add_edges_from(G.aresta)
print(G1.nodes)
pos = nx.spring_layout(G=G1, seed=42, scale =2)

##
def atualiza_grafo_A(grafo, a, color_map, number_pictures):
  lista_nodes = list(G1.nodes)
  for i in range(len(lista_nodes)):
    if lista_nodes[i] == a:
      color_map[i] = 'red'
  nx.draw_networkx(G1, pos=pos, node_color=color_map)  
  filename = 'AlgoritmoA/A' + str(number_pictures) + '.png'
  plt.savefig(filename)
  plt.show()
  #time.sleep(2)
  plt.close()

def ordena(a):
  return a[0]

def distancia_dois_pontos(o,d):
   a = (ListVert[o][0]-ListVert[d][0])**2
   b = (ListVert[o][1]-ListVert[d][1])**2
   return math.sqrt(a+b)

##
def ciclo_de_busca_visualizacao(d, grafo, color_map, visitado, a, cam, dist, number_pictures):
  cam.append(a)
  som = []

  atualiza_grafo(grafo, a, color_map, number_pictures, caseA)
  number_pictures = number_pictures + 1

  if(a == d):
    return cam, dist, number_pictures

  for i in range (len(grafo[a])): # for para adicionar os filhos do grafo atual na fila
    if visitado[i] == False and grafo[a][i] > 0: # caso nao esteja conectado, grafo[a][i] == -1, portanto precisa checar se é maior que 0
      som.append([grafo[a][i]+ distancia_dois_pontos(i,d), i, grafo[a][i]]) # +DISTTOT
      visitado[i] = True
      if i == d: # Se alcancar o destino, nao soma as  distancias dos filhos subsequentes
        dist += grafo[a][i]
        cam.append(i)
        return cam, dist, number_pictures


  som.sort(key=ordena)
  if len(som) != 0:
    som2, m, dist = som[0]
    som.pop(0)
    cam, dist, number_pictures = ciclo_de_busca_visualizacao(d, grafo, color_map, visitado, m, cam, dist, number_pictures)
    visitado[m] = False
    while dist == -1 and len(som) != 0:
      som2, m, dist = som[0]
      som.pop(0)
      cam, dist, number_pictures = ciclo_de_busca_visualizacao(d, grafo, color_map, visitado, m, cam, dist, number_pictures)

      visitado[m] = False
    return cam,dist, number_pictures
  else:
    return [], -1, number_pictures
def busca_A_visualizacao(o, d, grafo, number_pictures):
  visitado = [False] * len(grafo)
  visitado[o] = True
  dist = 0
  cam = []
  
  color_map = ['blue'] * len(G1.nodes)
  
  cam, dist, number_pictures = ciclo_de_busca_visualizacao(d, grafo, color_map,visitado,  o, cam, dist, number_pictures)
  if dist!= -1:
    atualiza_grafo(grafo,d, color_map, number_pictures, caseA)
    number_pictures = number_pictures + 1
  return cam, dist
  

o = 0
d = 4
number_pictures = 0
cam, dist = busca_A_visualizacao(o, d, Grafo, number_pictures)
#printa(Grafo)
print(cam)
print(round(dist, 2))