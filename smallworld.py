# -*- coding: utf-8 -*-
"""Copy of Smallworld.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12B3BgTnWOg6ANjqXbfiGvrm5dMTdast-

### Mudei a implementação mas acho que ta funcionando agora
"""

#pip install networkx

import random 
import math 

class Aresta:
  def __init__(self, distancia, origem, destino):
    self.distancia = distancia
    self.origem = origem
    self.destino = destino

def f(a):
  return a.distancia

def seleciona(lista, k, MatrizArestas):
  #ordena as distancias em ordem crescente 
  lista.sort(key=f) 
  lista = lista[:k]
  for i in range (0, k):
    #estabelecemos conexoes bi-direcionais
    MatrizArestas[lista[i].origem][lista[i].destino] = lista[i].distancia
    MatrizArestas[lista[i].destino][lista[i].origem] = lista[i].distancia

  return MatrizArestas


def gera_vertices(n):
  lista = []
  for i in range (0, n):
    numx = random.random() * n
    numy = random.random() * n
    parord = [numx, numy]
    lista.append(parord)
  return lista

def gera_arestas(lista, k):
  tamanho = len(lista) 
  MatrizArestas = [[0]*tamanho for i in range(tamanho)]

  for x in range(tamanho):
     for y in range(tamanho):
        MatrizArestas[x][y] = -1 #definimos distancias negativas como nao conexoes

  for origem in range(0, tamanho):
    distElem = [] #criamos uma lista de distancias de um elemento para todos os outros
    for destino in range(0, tamanho):
      if(origem != destino): #para que ele nao possa se conectar com ele mesmo
        distElem.append(Aresta(math.sqrt(pow(lista[origem][0] - lista[destino][0], 2) + pow(lista[origem][1] - lista[destino][1], 2)), origem, destino))

    #seleciona as k menores distancias e atualiza a matriz
    MatrizArestas = seleciona(distElem, k, MatrizArestas)

  return MatrizArestas

def gera_rede_knn(n, k):
  listavertices = gera_vertices(n)
  grafo = gera_arestas(listavertices, k)

  return listavertices, grafo

def reconecta_aresta(listavertices, grafo, p): 
  tamanho = len(listavertices) 
  for vert in range(tamanho):
    for aresta in range(vert + 1): # como a matrix eh simetrica nao precisamos percorrer ela por completo, apenas ate a diagonal principal
      if(grafo[vert][aresta] != -1 and p > random.random()): #cria nova conexao
        grafo[vert][aresta] = -1 #apaga a conexao
        grafo[aresta][vert] = -1
        
        n = 1
        while(n):
          novaConec = int(random.random() * tamanho)
          if(novaConec != vert): #nao pode se conectar consigo mesmo
            n = 0

        novaDist = math.sqrt(pow(listavertices[vert][0] - listavertices[novaConec][0], 2) + pow(listavertices[vert][1] - listavertices[novaConec][1], 2))

        grafo[vert][novaConec] = novaDist
        grafo[novaConec][vert] = novaDist


  return grafo

def printa(Grafo):
  for i in range(len(Grafo)):
    print('Vertice:', i)
    for j in range(len(Grafo[i])):
      if(Grafo[i][j] != -1):
        print('Conexões:', j, 'Distancia:', round(Grafo[i][j], 3))

ListVert, Grafo = gera_rede_knn(10, 2)
#printa(Grafo)
#print('-------------------------------------------------------------------')
reconecta_aresta(ListVert, Grafo, 0.1)
#printa(Grafo)


import networkx as nx
import matplotlib.pyplot as plt

class VisualGrafo:
  def __init__(self):
    self.aresta = []
  
  def adiciona(self, conexao):
    self.aresta.append(conexao)
  
  def visualizacao(self):
    G = nx.Graph()
    G.add_edges_from(self.aresta)
    nx.draw_networkx(G)
    plt.show()

G = VisualGrafo()
for i in range(len(Grafo)):
    for j in range(i + 1):
      if(Grafo[i][j] != -1):
        G.adiciona([i, j]) 
         
G.visualizacao()

"""#Busca em Largura

"""

#busca largura 

import time

caseLargura = 1
caseProf = 2
caseBestFirst = 3
caseA = 4

G = VisualGrafo()
for i in range(len(Grafo)):
    for j in range(i + 1):
      if(Grafo[i][j] != -1):
        G.adiciona([i, j]) 

G1 = nx.Graph()
G1.add_edges_from(G.aresta)
print(G1.nodes)
pos = nx.spring_layout(G=G1, seed=42)

#time.sleep(2)

def atualiza_grafo(grafo, a, color_map, num, case):
  lista_nodes = list(G1.nodes)
  for i in range(len(lista_nodes)):
    if lista_nodes[i] == a:
      color_map[i] = 'red'
  nx.draw_networkx(G1, pos=pos, node_color=color_map)  

  if case == caseLargura:
    filename = 'Largura/largura' + str(num) + '.png'

  if case == caseProf:
    filename = 'Profundidade/profundidade' + str(num) + '.png'

  if case == caseBestFirst:
    filename = 'BestFirst/bf' + str(num) + '.png'

  if case == caseA:
    filename = 'AlgoritmoA/A' + str(num) + '.png'
  
  plt.savefig(filename)
  #plt.show()
  #time.sleep(2)
  plt.close()

def busca_largura(o, d, grafo):
  fila = [o] # Fila dos vértices que serão analisados
  visitado = [False] * len(grafo)
  visitado[o] = True
  dist = 0
  cam = []

  color_map = ['blue'] * len(G1.nodes)

  number_pictures = 0
  while fila != []:
    a = fila.pop(0)
    
    cam.append(a)
    atualiza_grafo(grafo, a, color_map, number_pictures, caseLargura)

    if(a == d):
      return cam, dist

    for i in range (len(grafo[a])): # for para adicionar os filhos do grafo atual na fila
      if visitado[i] == False and grafo[a][i] > 0: # caso nao esteja conectado, grafo[a][i] == -1, portanto precisa checar se é maior que 0
        fila.append(i)
        visitado[i] = True
        dist += grafo[a][i]
        if i == d: # Se alcancar o destino, nao soma as  distancias dos filhos subsequentes
          break

    number_pictures = number_pictures + 1
  '''
    for i in range(n):
      if visitado[i] == False  and grafo[a][i] > 0:
        fila.append(i)
        visitado[i] = True
        dist += grafo[a][i]
        if i == d:
          cam.append(i)
          return cam, dist
  '''
  return [], -1

o = 0
d = 4
cam, dist = busca_largura(o, d, Grafo)
print(cam)
print(round(dist, 2))

"""#Busca em Profundidade"""

#busca profundidade

def busca_prof_rec(o, d, grafo, visitado, dist, parada, color_map, number_pictures):
  number_pictures = number_pictures + 1
  atualiza_grafo(grafo, o, color_map, number_pictures, caseProf)
  visitado.append(o)
  for i in range (len(grafo[o])):
    if i not in visitado and grafo[o][i] > 0:
      if parada == True:
        return visitado, dist, parada
      dist += grafo[o][i]
      if i == d:
        visitado.append(i)
        parada = True
        return visitado, dist, parada 
      visitado, dist, parada = busca_prof_rec(i, d, grafo, visitado, dist, parada, color_map, number_pictures)

  return visitado, dist, parada, number_pictures

def busca_profundidade(o, d, grafo):
  visitado = []
  parada = False
  dist = 0
  color_map = ['blue'] * len(G1.nodes)

  number_pictures = -1

  visitado, dist, parada, number_pictures = busca_prof_rec(o, d, grafo, visitado, dist, parada, color_map, number_pictures)
  if parada == True:
    atualiza_grafo(grafo, d, color_map, number_pictures, caseProf)
  else:
    visitado = []
    dist = -1
  return visitado, dist

o = 0
d = 4
cam, dist = busca_profundidade(o, d, Grafo)
print(cam)
print(round(dist, 2))

"""#Busca Best-First"""

from queue import PriorityQueue

v = 14
graph = [[] for i in range(v)]

def best_first_search(actual_Src, target, n):
	visited = [False] * n
	pq = PriorityQueue()
	pq.put((0, actual_Src))
	visited[actual_Src] = True
	
	while pq.empty() == False:
		u = pq.get()[1]
		# Displaying the path having lowest cost
		print(u, end=" ")
		if u == target:
			break

		for v, c in graph[u]:
			if visited[v] == False:
				visited[v] = True
				pq.put((c, v))
	print()

# Function for adding edges to graph


def addedge(x, y, cost):
	graph[x].append((y, cost))
	graph[y].append((x, cost))


# integers addedge(x,y,cost);
addedge(0, 1, 3)
addedge(0, 2, 6)
addedge(0, 3, 5)
addedge(1, 4, 9)
addedge(1, 5, 8)
addedge(2, 6, 12)
addedge(2, 7, 14)
addedge(3, 8, 7)
addedge(8, 9, 5)
addedge(8, 10, 6)
addedge(9, 11, 1)
addedge(9, 12, 10)
addedge(9, 13, 2)

source = 0
target = 9
best_first_search(source, target, v)

"""  #Algoritmo A*

"""



"""# Visualização das buscas"""

ListVert, Grafo = gera_rede_knn(10, 2)
reconecta_aresta(ListVert, Grafo, 0.7)

G = VisualGrafo()
for i in range(len(Grafo)):
    for j in range(i + 1):
      if(Grafo[i][j] != -1):
        G.adiciona([i, j]) 

G1 = nx.Graph()
G1.add_edges_from(G.aresta)
pos = nx.spring_layout(G=G1, seed=42)

o = 3
d = 4
cam, dist = busca_largura(o, d, Grafo)
print('Busca em Largura ----------------')
print('Caminho: ', cam)
print('Distancia percorrida: ', dist)
cam, dist = busca_profundidade(o, d, Grafo)
print('Busca em Profundidade -----------')
print('Caminho: ', cam)
print('Distancia percorrida: ', dist)
# Busca Best First
# print('Busca Best First -----------')
# print('Caminho: ', cam)
# print('Distancia percorrida: ', dist)
# Busca A*
#print('Busca A* -----------')
#print('Caminho: ', cam)
#print('Distancia percorrida: ', dist)



"""#Avaliação de Desempenho"""

ListVert, Grafo = gera_rede_knn(2000, 7)
reconecta_aresta(ListVert, Grafo, 0.1)

pontos = [(int(random.random() * 100) % len(Grafo), int(random.random() * 100) % len(Grafo)) for i in range(10)]
print(pontos)

tempo_largura = 0
for i in range (10):
  o, d = pontos(i)
  start = time.time()
  busca_largura(o, d, Grafo)
  end = time.time()
  tempo_largura += (end - start) / 10
print('Tempo busca largura: ', tempo_largura)
'''
cam, dist = busca_largura(o, d, Grafo)
print('Busca em Largura ----------------')
print('Caminho: ', cam)
print('Distancia percorrida: ', dist)
cam, dist = busca_profundidade(o, d, Grafo)
print('Busca em Profundidade -----------')
print('Caminho: ', cam)
print('Distancia percorrida: ', dist)
# Busca Best First
# print('Busca Best First -----------')
# print('Caminho: ', cam)
# print('Distancia percorrida: ', dist)
# Busca A*
#print('Busca A* -----------')
#print('Caminho: ', cam)
#print('Distancia percorrida: ', dist)
'''